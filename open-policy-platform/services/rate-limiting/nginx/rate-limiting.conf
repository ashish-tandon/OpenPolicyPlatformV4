# Nginx Rate Limiting Configuration for OpenPolicy Platform
# Provides multi-layer rate limiting and DDoS protection

# Define rate limiting zones
# $binary_remote_addr uses client IP in binary format (more efficient)
# $server_name for per-domain limits
# $request_uri for per-endpoint limits

# Global rate limits per IP
limit_req_zone $binary_remote_addr zone=global_limit:10m rate=10r/s;
limit_req_zone $binary_remote_addr zone=strict_limit:10m rate=1r/s;
limit_req_zone $binary_remote_addr zone=api_limit:10m rate=50r/s;

# Per-user rate limits (requires user ID in header or cookie)
map $http_x_user_id $user_id {
    default $binary_remote_addr;
    "~.+" $http_x_user_id;
}
limit_req_zone $user_id zone=user_limit:10m rate=100r/s;

# API key rate limits
limit_req_zone $http_x_api_key zone=api_key_limit:10m rate=1000r/m;

# Connection limits
limit_conn_zone $binary_remote_addr zone=conn_limit_per_ip:10m;
limit_conn_zone $server_name zone=conn_limit_per_server:10m;

# Request size limits
client_body_buffer_size 10K;
client_header_buffer_size 1k;
client_max_body_size 10m;
large_client_header_buffers 2 1k;

# Timeouts for DDoS protection
client_body_timeout 12;
client_header_timeout 12;
keepalive_timeout 15;
send_timeout 10;

# GeoIP blocking (requires ngx_http_geoip_module)
geoip_country /usr/share/GeoIP/GeoIP.dat;
map $geoip_country_code $allowed_country {
    default yes;
    CN no;  # China
    RU no;  # Russia
    KP no;  # North Korea
}

# User-Agent filtering
map $http_user_agent $bad_bot {
    default 0;
    ~*^$ 1;  # Empty user agent
    ~*(bot|crawler|spider|scraper) 1;
    ~*(curl|wget|python|java) 1;
    ~*(nikto|sqlmap|scanner) 1;
}

# Referer spam blocking
map $http_referer $bad_referer {
    default 0;
    ~*(poker|casino|porn) 1;
    ~*(drugs|pharmacy) 1;
}

# Request method filtering
map $request_method $bad_method {
    default 0;
    ~*(CONNECT|TRACE) 1;
}

# Combined bad request detection
map $bad_bot$bad_referer$bad_method $bad_request {
    default 0;
    ~*[1-9] 1;
}

# Server configuration
server {
    listen 80;
    server_name openpolicy.com api.openpolicy.com;

    # Block bad countries
    if ($allowed_country = no) {
        return 403;
    }

    # Block bad requests
    if ($bad_request) {
        return 403;
    }

    # Global connection limits
    limit_conn conn_limit_per_ip 10;
    limit_conn conn_limit_per_server 100;

    # Error pages for rate limiting
    error_page 503 = @rate_limit_error;
    location @rate_limit_error {
        default_type application/json;
        return 429 '{"error":"Too Many Requests","message":"Rate limit exceeded. Please try again later.","retry_after":60}';
    }

    # Health check endpoint (no rate limiting)
    location /health {
        access_log off;
        return 200 "healthy\n";
    }

    # Static assets (relaxed limits)
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|pdf|woff|woff2)$ {
        limit_req zone=global_limit burst=20 nodelay;
        limit_req_status 429;
        
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # API endpoints
    location /api/ {
        # Check rate limit service first
        auth_request /internal/check_rate_limit;
        auth_request_set $rate_limit_allowed $upstream_http_x_rate_limit_allowed;
        auth_request_set $rate_limit_remaining $upstream_http_x_rate_limit_remaining;
        auth_request_set $rate_limit_reset $upstream_http_x_rate_limit_reset;

        # Add rate limit headers
        add_header X-RateLimit-Limit 1000 always;
        add_header X-RateLimit-Remaining $rate_limit_remaining always;
        add_header X-RateLimit-Reset $rate_limit_reset always;

        # Apply Nginx rate limiting as backup
        limit_req zone=api_limit burst=100 nodelay;
        limit_req_status 429;

        # Security headers
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-Frame-Options "DENY" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;

        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Authentication endpoints (strict limits)
    location ~ ^/api/(auth|login|register) {
        limit_req zone=strict_limit burst=2 nodelay;
        limit_req_status 429;
        
        # Additional brute force protection
        limit_req zone=global_limit burst=5;

        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }

    # Search endpoint (prevent abuse)
    location /api/search {
        limit_req zone=user_limit burst=5 nodelay;
        limit_req_status 429;

        # Limit request body size for search
        client_max_body_size 1k;

        proxy_pass http://api_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-User-ID $user_id;
    }

    # Admin endpoints (IP whitelist + rate limit)
    location /admin/ {
        # IP whitelist
        allow 10.0.0.0/8;      # Internal network
        allow 172.16.0.0/12;   # Docker network
        allow 192.168.0.0/16;  # Local network
        deny all;

        limit_req zone=strict_limit burst=10 nodelay;
        
        proxy_pass http://admin_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Internal rate limit check
    location = /internal/check_rate_limit {
        internal;
        proxy_pass http://rate-limiter:9026/check;
        proxy_method POST;
        proxy_set_header Content-Type "application/json";
        proxy_set_body '{
            "client_ip": "$remote_addr",
            "user_id": "$http_x_user_id",
            "user_role": "$http_x_user_role",
            "endpoint": "$request_uri",
            "method": "$request_method",
            "api_key": "$http_x_api_key"
        }';
    }

    # WebSocket connections (different limits)
    location /ws/ {
        limit_conn conn_limit_per_ip 2;  # Max 2 WebSocket connections per IP
        
        proxy_pass http://websocket_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        
        # WebSocket specific timeouts
        proxy_connect_timeout 7d;
        proxy_send_timeout 7d;
        proxy_read_timeout 7d;
    }

    # Default location
    location / {
        limit_req zone=global_limit burst=10 nodelay;
        limit_req_status 429;

        proxy_pass http://web_backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}

# Upstream definitions
upstream api_backend {
    least_conn;
    server api-service:9000 max_fails=3 fail_timeout=30s;
    server api-service:9001 max_fails=3 fail_timeout=30s;
    server api-service:9002 max_fails=3 fail_timeout=30s;
    
    keepalive 32;
}

upstream admin_backend {
    server admin-service:9010;
}

upstream web_backend {
    server web-service:3000;
    server web-service:3001;
    server web-service:3002;
}

upstream websocket_backend {
    ip_hash;  # Sticky sessions for WebSocket
    server ws-service:9020;
    server ws-service:9021;
}

# DDoS protection with fail2ban integration
# Log format for fail2ban
log_format fail2ban '$remote_addr - $remote_user [$time_local] '
                    '"$request" $status $body_bytes_sent '
                    '"$http_referer" "$http_user_agent"';

# Custom error pages
error_page 429 /errors/429.json;
location = /errors/429.json {
    internal;
    default_type application/json;
    return 429 '{
        "error": "Too Many Requests",
        "message": "You have exceeded the rate limit. Please try again later.",
        "retry_after": 60,
        "support": "https://openpolicy.com/support/rate-limits"
    }';
}

error_page 403 /errors/403.json;
location = /errors/403.json {
    internal;
    default_type application/json;
    return 403 '{
        "error": "Forbidden",
        "message": "Access denied. Your request has been blocked.",
        "reason": "security_policy",
        "support": "https://openpolicy.com/support/access-denied"
    }';
}

# Advanced rate limiting with Lua (requires OpenResty)
# location /api/v2/ {
#     access_by_lua_block {
#         local limit_req = require "resty.limit.req"
#         
#         -- Create different limiters
#         local lim_global, err = limit_req.new("rate_limit_store", 100, 50)  -- 100 req/s, burst 50
#         local lim_user, err = limit_req.new("rate_limit_store", 50, 20)    -- 50 req/s, burst 20
#         
#         -- Get identifiers
#         local key_global = ngx.var.binary_remote_addr
#         local key_user = ngx.var.http_x_user_id or key_global
#         
#         -- Check global limit
#         local delay, err = lim_global:incoming(key_global, true)
#         if not delay then
#             if err == "rejected" then
#                 return ngx.exit(429)
#             end
#             ngx.log(ngx.ERR, "failed to limit req: ", err)
#             return ngx.exit(500)
#         end
#         
#         -- Check user limit
#         local delay_user, err = lim_user:incoming(key_user, true)
#         if not delay_user then
#             if err == "rejected" then
#                 return ngx.exit(429)
#             end
#         end
#         
#         -- Add delay if needed
#         if delay >= 0.001 then
#             ngx.sleep(delay)
#         end
#     }
#     
#     proxy_pass http://api_backend;
# }